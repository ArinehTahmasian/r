---
title: Dataframes
teaching: 25
exercises: 15
questions:
  - "What is a dataframe?"
  - "Why use a dataframe as a tidy data structure?"
objectives:
  - "To learn how to create a dataframe."
  - "To understand how to find basic information about a dataframe"
  - "To know how to inspect the data in a dataframe"
keypoints:
  - "Dataframes (or tibbles in the tidyverse) are lists where each element is a vector of the same length"
  - "Create them with `data_frame()`"
  - "Use `nrow()`, `ncol()`, `dim()`, or `colnames()` to find information about a dataframe"
  - "Use `head()`, `tail()`, `summary()`, or `glimpse()` to inspect a dataframe's content"
source: Rmd
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("06-")

library(tidyverse)
options(max.print = 80)
```


Now that we understand a little bit about why we might prefer our data to be 'tidy', we have one data
structure left to learn - the dataframe. Dataframes are where the vast majority of work in R is done. Dataframes can look a lot like any table of data (and we will often refer to them in that way), but they are a very particular structure. Dataframes are a special type of list that is made up of vectors
that all have to be the same length. Remembering that vectors must have the same type of values, this means that a dataframe produces a rectangular table of data, where each column **must** have the same type. We can see this below using the `diamonds` data set that is loaded as part of the tidyverse. 

Dataframes are an ideal format for storing and working with tidy data. All the tidyverse tools we will be learning
from here are designed to work with data in this form.

```{r tibble}
diamonds
```

> ## What's a tibble?
> You might notice in the output above that it calls itself a tibble, rather than a dataframe.
> A tibble is just the tidyverse's version of a dataframe that has a few behaviours tweaked to 
> make it behave more predictibly. Try comparing the output of a base R `data.frame` version of 
> diamonds with `as.data.frame(diamonds)` to get some idea of the differences.
> 
> We will try to refer to them as dataframes throughout these lessons. But know that dataframes
> and tibbles are interchangable for our purposes.
{: .callout}


## Inspecting a dataframe

Looking at the printed output from the `diamonds` dataframe can tell us a lot of information about
it. The first line tells us the dimensions of the data, in this case there are 53,940 rows and 10 
columns. This information can also be found with:
```{r data-frame-dimensions}
nrow(diamonds)
ncol(diamonds)
dim(diamonds)
```

The next row of output gives the names of the columns, which can also be found using `colnames()`.

```{r data-frame-colnames}
colnames(diamonds)
```

The next row tells you the data type of each column, followed by the data itself.

### A note on subsetting

We will not focus on these methods, but it is important to know that there are a range of ways to access parts of data structures in R. 

Elements can be accessed using either `$` or `[[` notation.

```{r df-dollar}
# Use $ to access by name
diamonds$price

# Use [[ ]] to access by name or position 
diamonds[["price"]]
diamonds[[7]]
```

While it might seem confusing, dataframes can also be subset using `[`. In this case, you call it 
using `data_frame[row_selector , column_selector]`. Where `row_selector` and `column_selector` can
be a set of numeric indexes or names to extract, or a vector of logical TRUE/FALSEs that show which
rows/column to keep.

```{r df-subset}
#First 5 rows
diamonds[1:5, ]

#First 5 columns, don't forget the comma
diamonds[, 1:5]

#Rows 1, 3 and 5 with the carat and price columns
diamonds[c(1, 3, 5), c("carat", "price")]
```

At this stage, don't let this subsetting confuse you - we're going to focus on more natural ways to do these tasks soon. But if you're working with other people's R code, you are definitely going to come across `$`, `[` and `[[`, so it's important to have some idea of what is going on.

## Overview of a dataframe
There are many other ways to view the data and look at its data types, and the
structure of the data. To look at the first 5 rows of the diamonds dataset, use `head()`:

```{r df-head}
head(diamonds, 5)
```

and use `tail()` to look at the last 10 rows:

```{r df-tail}
tail(diamonds, 10)
```

To look at the structure of the data (particularly when there are many columns) use `glimpse()`:

```{r df-glimpse}
glimpse(diamonds)
```

And use `summary()` to get a summarised breakdown of each column:

```{r df-summary}
summary(diamonds)
```

> ## Challenge 1
>
> What does the output from `summary(diamonds)` show you? Why do you think it has a different format
> for different columns?
>
> > ## Solution to Challenge 1
> > The output from `summary()` changes depending on the class of the data in the column. For the numeric
> > columns it shows the minimum, maximum, mean and quartile values. For the others, it shows a count 
> > of the contents.
> {: .solution}
{: .challenge}

## Factors

The `cut`, `color`, and `clarity` columns in the `diamonds` data set might be a little confusing. What
is this `<ord>` type, and why are they summarised as a count of the individual terms? These columns 
are each *factors* (specifically ordered factors, hence the `<ord>`), which usually look like character 
data, but are typically used to represent categorical information.

```{r}
class(diamonds$cut)
diamonds$cut
```

Here you can see that the `cut` column in the `diamonds` data set appears to be a character vector,
listing the quality of the diamond's cut. In the final line, you can see that there are a set of 
levels of this factor: "Fair < Good < Very Good < Premium < Ideal". The levels of this factor can
also be accessed using:

```{r df-levels}
levels(diamonds$cut)
```
 
But what happens when we look more closely at this data using `glimpse()`

```{r glimpse-factor}
glimpse(diamonds$cut)
```

This tells us we have an ordered factor with 5 levels, just like we expected. But when it comes to 
show the data itself, all we see are a bunch of numbers. This is because, to R, a factor is really 
just an integer underneath, with the levels telling it how to map the integer to the actual category.
So a value of 1 would map to the first level (`Fair`), while a value of 4 would map to the fourth
level (`Premium`).

Expecting factors to behave as characters, rather than integers, is a common cause of errors for 
people new to R. So always remember to inspect your data with the methods shown here to make sure it
is of the right type.

## Your turn
So far, you've been walked through investigating a dataframe. Let's use those skills to explore a
data set you have not yet been exposed to. 

> ## Challenge 2
>
> The `storms` data set contains information on hurricanes recorded in the Atlantic Ocean. Using the 
> tools you have learned so far, explore this data set and describe what it contains. Explain both
> the structural features of the data set as a whole, as well as its content.
>
> > ## Solution to Challenge 2
> >
> > The object `storms` is a dataframe (a tibble) with 10,010 rows and 13 columns.
> > - `name` and `status` are character vectors.
> > - `year`, `month`, `hour`, `lat`, `long`, `ts_diamater` and `hu_diameter` are numeric vectors.
> > - `day`, `wind`, and `pressure` are integer vectors.
> > - `category` is an ordered factor vector, with levels `-1 < 0 < 1 < 2 < 3 < 4 < 5`
> >
> {: .solution}
{: .challenge}

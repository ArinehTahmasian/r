---
title: Creating New Variables
teaching: 20
exercises: 15
questions:
  - "How can I create new variables in my data frame?"
  - "How do I deal with a data frame made up of different groups?"
objectives:
  - "Create new columns by performing calculations on old variables."
  - "Use functions to create new variables."
keypoints:
  - "Use `mutate()` to create new variables from old ones."
  - "You can create new variables using any function that returns a vector of the same length as the data frame."
  - "Use `group_by()` to group your data based on a variable."
source: Rmd
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("12-")

library(tidyverse)
gapminder <- read_csv("data/gapminder.csv")
```

So far, we have been looking at functions that deal just with the variables in our data frame. But
what if we are needing to create *new* variables? For that task, we will use the `mutate()` function
from the [dplyr](https://dplyr.tidyverse.org) package of the tidyverse.

To create a new variable, you provide `mutate()` with the name of the new column and how to calculate
the new value
```{r mutate-intro}
mutate(gapminder, gdp = gdpPercap * pop)
```

This line adds a new column to our gapminder data called `gdp` and the value in this column is 
calculated by multiplying the `gdpPercap` and the `pop` figure for each row.

You are not limited to mathematical operators in creating new columns. Any function that produces a
value for each row can be used:

```{r mutate-function}
# Take the logarithm of the population value
mutate(gapminder, log_pop = log(pop))

# Abbreviate the country name
# str_sub() takes a subset of a string from the given coordinates
mutate(gapminder, country_abbr = str_sub(country, start = 1, end = 4))
```

## Chaining mutates
One useful feature is that you can refer to your created columns later on in the same
`mutate()` call.

```{r mutate-chaining}
gapminder %>% 
  mutate(
    gdp = gdpPercap * pop,
    log_gdp = log(gdp)
  )
```


> ## Challenge 1
> Create a column in the gapminder data showing the life expectancy in days and one for GDP in billions
> of dollars
> > ## Solution to Challenge 1
> > ``` {r mutate-sol-1}
> > gapminder %>% 
> >   mutate(
> >     life_exp_days = lifeExp * 365,
> >     gdp_billion = gdpPercap * pop / 10^9
> > )
> > ```
> {: .solution}
{: .challenge}

## Variable creation functions
As mentioned before, any function that can take a vector of inputs and return a vector with the same 
length as an output can be used in a `mutate()` call. There are many R functions that can be used
in this situation, and `dplyr` introduces a number of new functions that may be useful for creating 
new variables. Some functions that you might find useful are:

#### Ranking functions
`min_rank()` ranks values in order from lowest to highest.
```{r}
mutate(gapminder, life_exp_rank = min_rank(lifeExp))
```

To rank highest to lowest, you can use `desc()` on the variable to rank in `desc`ending order.
```{r}
mutate(gapminder, life_exp_rank = min_rank(desc(lifeExp)))
```

#### Offset functions
To calculate differences between observations, you may be wanting to look at the value immediately
before or after it. These can be accessed using `lag()` or `lead()` respectively.
```{r}
mutate(gapminder, life_exp_prev = lag(lifeExp), life_exp_next = lead(lifeExp))
```

#### Cumulative computations
Cumulative sums (`cumsum()`), products(`cumprod()`) and means (`cummean()`) are all available to 
provide running computation of a variable. While not particularly useful for the gapminder data,
you can get an idea of how they function:

```{r mutate-cumsum}
mutate(gapminder, cumulative_life_exp = cumsum(lifeExp))
```

> ## Challenge 2
> Using an offset function, create a column showing the **change** in life expectancy between each sample period. Do any 
> countries have no change in life expectancy for a period?
> > ## Solution to Challenge 2
> > ``` {r mutate-sol-2}
> > gapminder %>% 
> >   mutate(life_exp_change = lifeExp - lag(lifeExp)) %>% 
> >   filter(life_exp_change == 0)
> > ```
> {: .solution}
{: .challenge}

> ## Challenge 3
> Look more carefully at the output from your previous solution. Is the life expectancy change you
> are calculating correct in every row? 
> > ## Hint
> > What is going on between rows 11 and 14?
> {: .solution}
> > ## Solution to Challenge 3
> > ``` {r mutate-sol-3}
> > mutated_data <- gapminder %>% 
> >   mutate(life_exp_change = lifeExp - lag(lifeExp))
> >
> > mutated_data[11:14, ]
> > ```
> > In row 13 the data switches from Afghanistan to Albania, so the new column is calculated as
> > Albania's life expectancy in 1952 minus Afghanistan's life expectancy in 2007. The calculated
> > value is therefore not comparable to the rest of the measurements.
> {: .solution}
{: .challenge}

## Operating on groups
The problem identified above is that the `lag()` function doesn't know that at some point the data 
changes country, and that it is not sensible to look at the previous value if it is from a different
country. To fix this problem, we can use `group_by()`

```{r mutate-group-intro}
gapminder %>% 
  group_by(country)
```

It might not look like much has changed here, but notice the `Groups:   country [142]` in the second
line. This is telling us that the gapminder dataset is now grouped by country (and that there are
142 groups in the data frame). Rather than one large data frame, this can be thought of as 142 
separate data frames that all have the same column structure and just happen to be stacked on top
of each other.

When you use one of the data manipulation functions we have looked at on a *grouped* data frame, it
will apply the function separately for each group.

> ## Challenge 4
> Repeat Challenge 3, but try to fix the problem you identified by grouping the data frame first.
> > ## Solution to Challenge 4
> > ``` {r mutate-sol-4}
> > mutated_by_group <- gapminder %>% 
> >   group_by(country) %>% 
> >   mutate(life_exp_change = lifeExp - lag(lifeExp))
> >   
> > mutated_by_group[11:14, ]
> > ```
> {: .solution}
{: .challenge}
---
title: Piping
teaching: 15
exercises: 10
questions:
objectives:
keypoints:
source: Rmd
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("11-")

library(tidyverse)
gapminder <- read_csv("data/gapminder.csv")
```

Now that we have started to learn a few data manipulation verbs you might begin to see how they 
could be used together. 

> ## Challenge 1
> With what you have learnt so far, create a data frame containing only the `country`, `year`, and 
> `pop` columns for Australian data.
{: .challenge}

Your solution to this challenge probably took one of two approaches:

#### Using an intermediate variable
~~~~
filtered_data <- filter(data, ...)

final_data <- select(filtered_data, ...)
~~~~
{: .language-r}

#### Nesting function calls
~~~~
final_data <- select(filter(data, ...), ...)
~~~~
{: .language-r}

Each of these are perfectly acceptable ways to solve the problem, but can lead to code that is 
difficult to read and understand. In the case of the intermediate variables, you need to come up 
with a name for each one, and if you aren't very careful about keeping the connected lines of code 
together it can become difficult to track which variable is being used in each function. The nested
version removes some of these problems, but imagine trying to work out what is happening in a line 
with five or more functions.

## Piping in R
From the [magrittr](https://magrittr.tidyverse.org) package in the tidyverse we have another approach
for chaining a sequence of functions. This is the pipe operator (`%>%`), which works in a similar 
way to the unix pipe.

> ## Shortcuts
> Typing `%>%` in everytime you want a pipe is a bit awkward, so RStudio has a shortcut to help.
> Use <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>M</kbd> (<kbd>Cmd</kbd>+<kbd>Shift</kbd>+<kbd>M</kbd> 
> on a Mac) to insert a pipe into your code.
{: .callout}

## Using the pipe
The pipe works by taking the output of it's left hand side and inserting it as the first argument 
to the function on it's right hand side.

This means that the following
~~~~
some_function(data)
~~~~
{: .language-r}
could be rewritten using a pipe as
~~~~
data %>% some_function()
~~~~
{: .language-r}
Other function arguments are left untouched so
~~~~
#Standard form
some_function(data, first_arg, second_arg)

#Piped form
data %>% some_function(first_arg, second_arg)
~~~~
{: .language-r}
are equivalent.

> ## Challenge 2
> Rewrite the following line from the previous lesson in a piped form. Does it give you the same 
> output?
>
> `filter(gapminder, country == "Australia", year >= 1997)`
> > ## Solution to Challenge 2
> > ``` {r piping-sol-2}
> > gapminder %>% 
> >     filter(country == "Australia", year >= 1997)
> > ```
> {: .solution}
{: .challenge}

## Chaining
The real value of the pipe comes when there are multiple steps to complete. To rewrite our example 
above using pipes:
~~~~
#Nested form
final_data <- select(filter(data, ...), ...)

#Piped form
final_data <- data %>% 
                filter(...) %>% 
                select(...)
~~~~
{: .language-r}

This can be read as a series of instructions. Take the data frame `data`, *then* `filter` it to keep
some rows, *then* `select` some columns. 

For many people, the piped form is one that is easier to read and understand, as well as easier to 
write. 

> ## Challenge 3
> Take your answer to Challenge 1 and rewrite it in a piped form.
> 
> Now, imagine that you have decided later more steps are required. Add a step renaming the `pop`
> column to `population` for both forms. Do you find one form easier to work with than the other?
> > ## Solution to Challenge 3
> > For the piped version:
> > ``` {r piping-sol-3-1}
> > gapminder %>% 
> >     select(country, year, pop) %>% 
> >     filter(country == "Australia")
> > ```
> > And adding a rename step:
> > ``` {r piping-sol-3-2}
> > gapminder %>% 
> >     select(country, year, pop) %>% 
> >     filter(country == "Australia") %>% 
> >     rename(population = pop)
> > ```
> {: .solution}
{: .challenge}   
  
## Common pitfalls
When using pipes to construct a sequential analysis, there are a few problems that can trip people up

#### Forgetting to assign the output
This has been covered before, but is something that often gets forgotten again once you start using
pipes. If the final output of your pipe is not saved into a variable, it will just get printed to 
the screen and then lost.

So instead of 
~~~~
gapminder %>% 
  select(country, year, pop) %>% 
  filter(country == "Australia") %>% 
  rename(population = pop)
~~~~
{: .language-r}

make sure to save the output if you need access to it later
~~~~
aust_data <- gapminder %>% 
  select(country, year, pop) %>% 
  filter(country == "Australia") %>% 
  rename(population = pop)
~~~~
{: .language-r}

#### Forgetting to pass some data in to the pipe
Some people have the opposite problem where they focus so much on getting each step of the pipe right
that they forget that it needs some data to work on.

Try running the pipe above without any data:
```{r piping-error}
select(country, year, pop) %>% 
  filter(country == "Australia") %>% 
  rename(population = pop)
```
It throws an error because `select()` in the first step is expecting it's first argument to be a 
data frame that it can work on. Instead, it finds `country`, which is not a data frame.

You could fix this by providing the data frame directly to select
~~~~
select(gapminder, country, year, pop) %>% 
  filter(country == "Australia") %>% 
  rename(population = pop)
~~~~
{: .language-r}

But it is easier to know exactly what data is going into a pipe if you put it on it's own line at 
the start
~~~~
gapminder %>% 
  select(country, year, pop) %>% 
  filter(country == "Australia") %>% 
  rename(population = pop)
~~~~
{: .language-r}

#### Overly long pipes
Using pipes can make your code more understandable, but there is a limit to their effectiveness. If
your pipe has too many steps it becomes harder to read through and keep in your memory all the steps 
that have been applied to the data. 

It also makes identifying errors harder. Imagine a pipe with 30 steps that is giving 
you the wrong output or throwing an error. Working out which of those 30 steps is the cause of the 
problem can become time consuming and difficult. If you find yourself writing very long pipes, 
consider if there are any logical ways to break it up into a series of smaller pipes.

## Style questions
There are a couple of style guidelines you can use when writing pipes to make them more 
understandable

#### Separate each step in a pipe
Each step of the pipe should be on a separate line, and all steps after the first should be indented.
This helps to clearly identify the elements of the pipe and read through them in a step-by-step 
fashion.

#### Comment sensibly
You *can* add comments into the middle of a pipe chain

~~~~
gapminder %>% 
  rename(gdpPerCap = gdpPercap) %>% # Inconsistent capitalisation annoys me
  select(country, year, gdpPerCap) %>% 
  # Data version of #MapsWithoutNZ
  filter(country != "New Zealand")
~~~~
{: .language-r}

but consider the effect those comments have on the legibility of your code. It may be best to add
your comment at the start of the pipe instead. Or to break the pipe up so that the complicated parts
needing comments are separated from the simpler steps.
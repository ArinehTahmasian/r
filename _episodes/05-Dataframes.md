---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 05-Dataframes.md in _episodes_rmd/
title: Dataframes
teaching: 25
exercises: 15
questions:
  - "What is a dataframe?"
  - "Why use a dataframe as a tidy data structure?"
objectives:
  - "To learn how to create a dataframe."
  - "To understand how to find basic information about a dataframe"
  - "To know how to inspect the data in a dataframe"
keypoints:
  - "Dataframes (or tibbles in the tidyverse) are lists where each element is a vector of the same length"
  - "Create them with `data_frame()`"
  - "Use `nrow()`, `ncol()`, `dim()`, or `colnames()` to find information about a dataframe"
  - "Use `head()`, `tail()`, `summary()`, or `glimpse()` to inspect a dataframe's content"
source: Rmd
---




Now that we understand a little bit about why we might prefer our data to be 'tidy', we have one data
structure left to learn - the dataframe. Dataframes are where the vast majority of work in R is done. Dataframes can look a lot like any table of data (and we will often refer to them in that way), but they are a very particular structure. Dataframes are a special type of list that is made up of vectors
that all have to be the same length. Remembering that vectors must have the same type of values, this means that a dataframe produces a rectangular table of data, where each column **must** have the same type. We can see this below using the `diamonds` data set that is loaded as part of the tidyverse. 

Dataframes are an ideal format for storing and working with tidy data. All the tidyverse tools we will be learning
from here are designed to work with data in this form.


~~~
diamonds
~~~
{: .language-r}



~~~
# A tibble: 53,940 x 10
   carat cut       color clarity depth table price     x     y     z
   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>
 1 0.23  Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43
 2 0.21  Premium   E     SI1      59.8    61   326  3.89  3.84  2.31
 3 0.23  Good      E     VS1      56.9    65   327  4.05  4.07  2.31
 4 0.290 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63
 5 0.31  Good      J     SI2      63.3    58   335  4.34  4.35  2.75
 6 0.24  Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48
 7 0.24  Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47
 8 0.26  Very Good H     SI1      61.9    55   337  4.07  4.11  2.53
 9 0.22  Fair      E     VS2      65.1    61   337  3.87  3.78  2.49
10 0.23  Very Good H     VS1      59.4    61   338  4     4.05  2.39
# … with 53,930 more rows
~~~
{: .output}

> ## What's a tibble?
> You might notice in the output above that it calls itself a tibble, rather than a dataframe.
> A tibble is just the tidyverse's version of a dataframe that has a few behaviours tweaked to 
> make it behave more predictibly. Try comparing the output of a base R `data.frame` version of 
> diamonds with `as.data.frame(diamonds)` to get some idea of the differences.
> 
> We will try to refer to them as dataframes throughout these lessons. But know that dataframes
> and tibbles are interchangable for our purposes.
{: .callout}


## Inspecting a dataframe

Looking at the printed output from the `diamonds` dataframe can tell us a lot of information about
it. The first line tells us the dimensions of the data, in this case there are 53,940 rows and 10 
columns. This information can also be found with:

~~~
nrow(diamonds)
~~~
{: .language-r}



~~~
[1] 53940
~~~
{: .output}



~~~
ncol(diamonds)
~~~
{: .language-r}



~~~
[1] 10
~~~
{: .output}



~~~
dim(diamonds)
~~~
{: .language-r}



~~~
[1] 53940    10
~~~
{: .output}

The next row of output gives the names of the columns, which can also be found using `colnames()`.


~~~
colnames(diamonds)
~~~
{: .language-r}



~~~
 [1] "carat"   "cut"     "color"   "clarity" "depth"   "table"   "price"  
 [8] "x"       "y"       "z"      
~~~
{: .output}

The next row tells you the data type of each column, followed by the data itself.

### A note on subsetting

We will not focus on these methods, but it is important to know that there are a range of ways to access parts of data structures in R. 

Elements can be accessed using either `$` or `[[` notation.


~~~
# Use $ to access by name
diamonds$price
~~~
{: .language-r}



~~~
 [1] 326 326 327 334 335 336 336 337 337 338 339 340 342 344 345 345 348
[18] 351 351 351 351 352 353 353 353 354 355 357 357 357 402 402 402 402
[35] 402 402 402 402 403 403 403 403 403 403 403 403 403 403 404 404 404
[52] 404 404 404 404 405 405 405 405 405 552 552 552 552 552 553 553 553
[69] 553 553 553 554 554 554 554 554 554 554 554 554
 [ reached getOption("max.print") -- omitted 53860 entries ]
~~~
{: .output}



~~~
# Use [[ ]] to access by name or position 
diamonds[["price"]]
~~~
{: .language-r}



~~~
 [1] 326 326 327 334 335 336 336 337 337 338 339 340 342 344 345 345 348
[18] 351 351 351 351 352 353 353 353 354 355 357 357 357 402 402 402 402
[35] 402 402 402 402 403 403 403 403 403 403 403 403 403 403 404 404 404
[52] 404 404 404 404 405 405 405 405 405 552 552 552 552 552 553 553 553
[69] 553 553 553 554 554 554 554 554 554 554 554 554
 [ reached getOption("max.print") -- omitted 53860 entries ]
~~~
{: .output}



~~~
diamonds[[7]]
~~~
{: .language-r}



~~~
 [1] 326 326 327 334 335 336 336 337 337 338 339 340 342 344 345 345 348
[18] 351 351 351 351 352 353 353 353 354 355 357 357 357 402 402 402 402
[35] 402 402 402 402 403 403 403 403 403 403 403 403 403 403 404 404 404
[52] 404 404 404 404 405 405 405 405 405 552 552 552 552 552 553 553 553
[69] 553 553 553 554 554 554 554 554 554 554 554 554
 [ reached getOption("max.print") -- omitted 53860 entries ]
~~~
{: .output}

While it might seem confusing, dataframes can also be subset using `[`. In this case, you call it 
using `data_frame[row_selector , column_selector]`. Where `row_selector` and `column_selector` can
be a set of numeric indexes or names to extract, or a vector of logical TRUE/FALSEs that show which
rows/column to keep.


~~~
#First 5 rows
diamonds[1:5, ]
~~~
{: .language-r}



~~~
# A tibble: 5 x 10
  carat cut     color clarity depth table price     x     y     z
  <dbl> <ord>   <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>
1 0.23  Ideal   E     SI2      61.5    55   326  3.95  3.98  2.43
2 0.21  Premium E     SI1      59.8    61   326  3.89  3.84  2.31
3 0.23  Good    E     VS1      56.9    65   327  4.05  4.07  2.31
4 0.290 Premium I     VS2      62.4    58   334  4.2   4.23  2.63
5 0.31  Good    J     SI2      63.3    58   335  4.34  4.35  2.75
~~~
{: .output}



~~~
#First 5 columns, don't forget the comma
diamonds[, 1:5]
~~~
{: .language-r}



~~~
# A tibble: 53,940 x 5
   carat cut       color clarity depth
   <dbl> <ord>     <ord> <ord>   <dbl>
 1 0.23  Ideal     E     SI2      61.5
 2 0.21  Premium   E     SI1      59.8
 3 0.23  Good      E     VS1      56.9
 4 0.290 Premium   I     VS2      62.4
 5 0.31  Good      J     SI2      63.3
 6 0.24  Very Good J     VVS2     62.8
 7 0.24  Very Good I     VVS1     62.3
 8 0.26  Very Good H     SI1      61.9
 9 0.22  Fair      E     VS2      65.1
10 0.23  Very Good H     VS1      59.4
# … with 53,930 more rows
~~~
{: .output}



~~~
#Rows 1, 3 and 5 with the carat and price columns
diamonds[c(1, 3, 5), c("carat", "price")]
~~~
{: .language-r}



~~~
# A tibble: 3 x 2
  carat price
  <dbl> <int>
1  0.23   326
2  0.23   327
3  0.31   335
~~~
{: .output}

At this stage, don't let this subsetting confuse you - we're going to focus on more natural ways to do these tasks soon. But if you're working with other people's R code, you are definitely going to come across `$`, `[` and `[[`, so it's important to have some idea of what is going on.

## Overview of a dataframe
There are many other ways to view the data and look at its data types, and the
structure of the data. To look at the first 5 rows of the diamonds dataset, use `head()`:


~~~
head(diamonds, 5)
~~~
{: .language-r}



~~~
# A tibble: 5 x 10
  carat cut     color clarity depth table price     x     y     z
  <dbl> <ord>   <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>
1 0.23  Ideal   E     SI2      61.5    55   326  3.95  3.98  2.43
2 0.21  Premium E     SI1      59.8    61   326  3.89  3.84  2.31
3 0.23  Good    E     VS1      56.9    65   327  4.05  4.07  2.31
4 0.290 Premium I     VS2      62.4    58   334  4.2   4.23  2.63
5 0.31  Good    J     SI2      63.3    58   335  4.34  4.35  2.75
~~~
{: .output}

and use `tail()` to look at the last 10 rows:


~~~
tail(diamonds, 10)
~~~
{: .language-r}



~~~
# A tibble: 10 x 10
   carat cut       color clarity depth table price     x     y     z
   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>
 1  0.71 Premium   E     SI1      60.5    55  2756  5.79  5.74  3.49
 2  0.71 Premium   F     SI1      59.8    62  2756  5.74  5.73  3.43
 3  0.7  Very Good E     VS2      60.5    59  2757  5.71  5.76  3.47
 4  0.7  Very Good E     VS2      61.2    59  2757  5.69  5.72  3.49
 5  0.72 Premium   D     SI1      62.7    59  2757  5.69  5.73  3.58
 6  0.72 Ideal     D     SI1      60.8    57  2757  5.75  5.76  3.5 
 7  0.72 Good      D     SI1      63.1    55  2757  5.69  5.75  3.61
 8  0.7  Very Good D     SI1      62.8    60  2757  5.66  5.68  3.56
 9  0.86 Premium   H     SI2      61      58  2757  6.15  6.12  3.74
10  0.75 Ideal     D     SI2      62.2    55  2757  5.83  5.87  3.64
~~~
{: .output}

To look at the structure of the data (particularly when there are many columns) use `glimpse()`:


~~~
glimpse(diamonds)
~~~
{: .language-r}



~~~
Observations: 53,940
Variables: 10
$ carat   <dbl> 0.23, 0.21, 0.23, 0.29, 0.31, 0.24, 0.24, 0.26, 0.22, 0.…
$ cut     <ord> Ideal, Premium, Good, Premium, Good, Very Good, Very Goo…
$ color   <ord> E, E, E, I, J, J, I, H, E, H, J, J, F, J, E, E, I, J, J,…
$ clarity <ord> SI2, SI1, VS1, VS2, SI2, VVS2, VVS1, SI1, VS2, VS1, SI1,…
$ depth   <dbl> 61.5, 59.8, 56.9, 62.4, 63.3, 62.8, 62.3, 61.9, 65.1, 59…
$ table   <dbl> 55, 61, 65, 58, 58, 57, 57, 55, 61, 61, 55, 56, 61, 54, …
$ price   <int> 326, 326, 327, 334, 335, 336, 336, 337, 337, 338, 339, 3…
$ x       <dbl> 3.95, 3.89, 4.05, 4.20, 4.34, 3.94, 3.95, 4.07, 3.87, 4.…
$ y       <dbl> 3.98, 3.84, 4.07, 4.23, 4.35, 3.96, 3.98, 4.11, 3.78, 4.…
$ z       <dbl> 2.43, 2.31, 2.31, 2.63, 2.75, 2.48, 2.47, 2.53, 2.49, 2.…
~~~
{: .output}

And use `summary()` to get a summarised breakdown of each column:


~~~
summary(diamonds)
~~~
{: .language-r}



~~~
     carat               cut        color        clarity     
 Min.   :0.2000   Fair     : 1610   D: 6775   SI1    :13065  
 1st Qu.:0.4000   Good     : 4906   E: 9797   VS2    :12258  
 Median :0.7000   Very Good:12082   F: 9542   SI2    : 9194  
 Mean   :0.7979   Premium  :13791   G:11292   VS1    : 8171  
 3rd Qu.:1.0400   Ideal    :21551   H: 8304   VVS2   : 5066  
 Max.   :5.0100                     I: 5422   VVS1   : 3655  
                                    J: 2808   (Other): 2531  
     depth           table           price             x         
 Min.   :43.00   Min.   :43.00   Min.   :  326   Min.   : 0.000  
 1st Qu.:61.00   1st Qu.:56.00   1st Qu.:  950   1st Qu.: 4.710  
 Median :61.80   Median :57.00   Median : 2401   Median : 5.700  
 Mean   :61.75   Mean   :57.46   Mean   : 3933   Mean   : 5.731  
 3rd Qu.:62.50   3rd Qu.:59.00   3rd Qu.: 5324   3rd Qu.: 6.540  
 Max.   :79.00   Max.   :95.00   Max.   :18823   Max.   :10.740  
                                                                 
       y                z         
 Min.   : 0.000   Min.   : 0.000  
 1st Qu.: 4.720   1st Qu.: 2.910  
 Median : 5.710   Median : 3.530  
 Mean   : 5.735   Mean   : 3.539  
 3rd Qu.: 6.540   3rd Qu.: 4.040  
 Max.   :58.900   Max.   :31.800  
                                  
~~~
{: .output}

> ## Challenge 1
>
> What does the output from `summary(diamonds)` show you? Why do you think it has a different format
> for different columns?
>
> > ## Solution to Challenge 1
> > The output from `summary()` changes depending on the class of the data in the column. For the numeric
> > columns it shows the minimum, maximum, mean and quartile values. For the others, it shows a count 
> > of the contents.
> {: .solution}
{: .challenge}

## Factors

The `cut`, `color`, and `clarity` columns in the `diamonds` data set might be a little confusing. What
is this `<ord>` type, and why are they summarised as a count of the individual terms? These columns 
are each *factors* (specifically ordered factors, hence the `<ord>`), which usually look like character 
data, but are typically used to represent categorical information.


~~~
class(diamonds$cut)
~~~
{: .language-r}



~~~
[1] "ordered" "factor" 
~~~
{: .output}



~~~
diamonds$cut
~~~
{: .language-r}



~~~
 [1] Ideal     Premium   Good      Premium   Good      Very Good Very Good
 [8] Very Good Fair      Very Good Good      Ideal     Premium   Ideal    
[15] Premium   Premium   Ideal     Good      Good      Very Good Good     
[22] Very Good Very Good Very Good Very Good Very Good Premium   Very Good
[29] Very Good Very Good Very Good Very Good Very Good Very Good Very Good
[36] Good      Good      Good      Very Good Ideal     Ideal     Ideal    
[43] Good      Good      Good      Premium   Very Good Good      Very Good
[50] Very Good Very Good Ideal     Ideal     Premium   Premium   Ideal    
[57] Premium   Very Good Very Good Good      Ideal     Premium   Ideal    
[64] Ideal     Premium   Ideal     Ideal     Very Good Premium   Premium  
[71] Very Good Very Good Premium   Premium   Good      Very Good Very Good
[78] Very Good Very Good Very Good
 [ reached getOption("max.print") -- omitted 53860 entries ]
Levels: Fair < Good < Very Good < Premium < Ideal
~~~
{: .output}

Here you can see that the `cut` column in the `diamonds` data set appears to be a character vector,
listing the quality of the diamond's cut. In the final line, you can see that there are a set of 
levels of this factor: "Fair < Good < Very Good < Premium < Ideal". The levels of this factor can
also be accessed using:


~~~
levels(diamonds$cut)
~~~
{: .language-r}



~~~
[1] "Fair"      "Good"      "Very Good" "Premium"   "Ideal"    
~~~
{: .output}
 
But what happens when we look more closely at this data using `glimpse()`


~~~
glimpse(diamonds$cut)
~~~
{: .language-r}



~~~
 Ord.factor w/ 5 levels "Fair"<"Good"<..: 5 4 2 4 2 3 3 3 1 3 ...
~~~
{: .output}

This tells us we have an ordered factor with 5 levels, just like we expected. But when it comes to 
show the data itself, all we see are a bunch of numbers. This is because, to R, a factor is really 
just an integer underneath, with the levels telling it how to map the integer to the actual category.
So a value of 1 would map to the first level (`Fair`), while a value of 4 would map to the fourth
level (`Premium`).

Expecting factors to behave as characters, rather than integers, is a common cause of errors for 
people new to R. So always remember to inspect your data with the methods shown here to make sure it
is of the right type.

## Your turn
So far, you've been walked through investigating a dataframe. Let's use those skills to explore a
data set you have not yet been exposed to. 

> ## Challenge 2
>
> The `storms` data set contains information on hurricanes recorded in the Atlantic Ocean. Using the 
> tools you have learned so far, explore this data set and describe what it contains. Explain both
> the structural features of the data set as a whole, as well as its content.
>
> > ## Solution to Challenge 2
> >
> > The object `storms` is a dataframe (a tibble) with 10,010 rows and 13 columns.
> > - `name` and `status` are character vectors.
> > - `year`, `month`, `hour`, `lat`, `long`, `ts_diamater` and `hu_diameter` are numeric vectors.
> > - `day`, `wind`, and `pressure` are integer vectors.
> > - `category` is an ordered factor vector, with levels `-1 < 0 < 1 < 2 < 3 < 4 < 5`
> >
> {: .solution}
{: .challenge}

---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 14-Data-Verbs---join.md in _episodes_rmd/
title: Adding and Combining Datasets
teaching: 30
exercises: 30
questions:
  - "How can I combine multiple datasets?"
  - "How can I merge datasets that have a common variable?"
objectives:
  - "Be able to combine different datasets by row, column or common variable"
keypoints:
  - "`bind_rows` combines datasets that share the same variables"
  - "`bind_cols` combines datasets that share the same rows"
  - "The `join` family of functions provide a complete range of methods to merge datasets that share common variables"
source: Rmd
---



All the functions we have looked at so far work with a single data frame and modify it in some way.
It is common, however, that your data may not be stored in a single, complete, form and instead will
be found in a number of places. Perhaps measurements taken in different weeks have been saved to 
separate places, or maybe you have different files recording observations and metadata. To work with
data stored like this it is necessary to learn how to combine and merge different datasets into a
single data frame.

## Combining data

If you have new data that has the same structure as your old data, it can be added onto the end of 
your data frame with `bind_rows()`


~~~
data = tibble(numbers = c(1, 2, 3, 4), letters = c("a", "b", "c", "d"))
data
~~~
{: .language-r}



~~~
# A tibble: 4 x 2
  numbers letters
    <dbl> <chr>  
1       1 a      
2       2 b      
3       3 c      
4       4 d      
~~~
{: .output}



~~~
new_data <- tibble(numbers = c(24, 25, 26), letters = c("x", "y", "z"))

bind_rows(data, new_data)
~~~
{: .language-r}



~~~
# A tibble: 7 x 2
  numbers letters
    <dbl> <chr>  
1       1 a      
2       2 b      
3       3 c      
4       4 d      
5      24 x      
6      25 y      
7      26 z      
~~~
{: .output}

The columns are matched by name, so you need to make sure that both data frames are named 
consistently. If the names do not match, the data frames will still be bound together but any missing
data will be replaced with `NA`s


~~~
new_data <- tibble(numbers = c(24, 25, 26), more_letters = c("x", "y", "z"))

bind_rows(data, new_data)
~~~
{: .language-r}



~~~
# A tibble: 7 x 3
  numbers letters more_letters
    <dbl> <chr>   <chr>       
1       1 a       <NA>        
2       2 b       <NA>        
3       3 c       <NA>        
4       4 d       <NA>        
5      24 <NA>    x           
6      25 <NA>    y           
7      26 <NA>    z           
~~~
{: .output}

To add more columns to your data frame, use `bind_cols()`


~~~
new_data <- tibble(direction = c("N", "S", "E", "W"))

bind_cols(data, new_data)
~~~
{: .language-r}



~~~
# A tibble: 4 x 3
  numbers letters direction
    <dbl> <chr>   <chr>    
1       1 a       N        
2       2 b       S        
3       3 c       E        
4       4 d       W        
~~~
{: .output}

`bind_cols()` adds the new column data in the order provided, which means that it is your 
responsibility to make sure that the new data is the same length and in the same order as the 
original data.

## Merging data

If you are instead looking to merge data sets based on some shared variable, there are a number of
`join`s that are useful

Let’s make a couple of simple data frames to demonstrate how a join works. These two data frames 
will have a shared column with a sample ID, and an observed measurement which is different for each
data frame.


~~~
df1 <- tibble(sample = c(1, 2, 3), measure1 = c(4.2, 5.3, 6.1))
df2 <- tibble(sample = c(1, 3, 4), measure2 = c(7.8, 6.4, 9.0))

df1
~~~
{: .language-r}



~~~
# A tibble: 3 x 2
  sample measure1
   <dbl>    <dbl>
1      1      4.2
2      2      5.3
3      3      6.1
~~~
{: .output}



~~~
df2
~~~
{: .language-r}



~~~
# A tibble: 3 x 2
  sample measure2
   <dbl>    <dbl>
1      1      7.8
2      3      6.4
3      4      9  
~~~
{: .output}

To merge these two data frames together keeping all the data from both data frames, we can use `full_join()`


~~~
full_join(df1, df2)
~~~
{: .language-r}



~~~
Joining, by = "sample"
~~~
{: .output}



~~~
# A tibble: 4 x 3
  sample measure1 measure2
   <dbl>    <dbl>    <dbl>
1      1      4.2      7.8
2      2      5.3     NA  
3      3      6.1      6.4
4      4     NA        9  
~~~
{: .output}

By default, the `join` functions will join based on any shared column names between the two data 
frames (here just the `sample` column). You can control which columns are used to merge on with the
`by` argument.

~~~~
full_join(df1, df2, by = c("sample"))
~~~~
{: .language-r}

The other join functions are all variations on this that have different ways of dealing with data
that is present in one data frame and absent in the other.

The `inner_join()` only only keeps rows that are present in both data frames


~~~
inner_join(df1, df2)
~~~
{: .language-r}



~~~
# A tibble: 2 x 3
  sample measure1 measure2
   <dbl>    <dbl>    <dbl>
1      1      4.2      7.8
2      3      6.1      6.4
~~~
{: .output}

A `left_join()` keeps all rows from the left hand data frame, and adds any matched data from the 
right hand data frame


~~~
left_join(df1, df2)
~~~
{: .language-r}



~~~
# A tibble: 3 x 3
  sample measure1 measure2
   <dbl>    <dbl>    <dbl>
1      1      4.2      7.8
2      2      5.3     NA  
3      3      6.1      6.4
~~~
{: .output}

And a `right_join()` does the opposite


~~~
right_join(df1, df2)
~~~
{: .language-r}



~~~
# A tibble: 3 x 3
  sample measure1 measure2
   <dbl>    <dbl>    <dbl>
1      1      4.2      7.8
2      3      6.1      6.4
3      4     NA        9  
~~~
{: .output}

There are also two joins known as filtering joins, which don't merge the two data sets but instead 
use the second data frame as a way to filter the first.

For example, to keep rows in `df1` that have a matching sample in `df2`, use `semi_join()`


~~~
semi_join(df1, df2)
~~~
{: .language-r}



~~~
# A tibble: 2 x 2
  sample measure1
   <dbl>    <dbl>
1      1      4.2
2      3      6.1
~~~
{: .output}

The opposite of this is an `anti_join()`, which keeps all rows in `df1` which do **not** have a 
matching sample in `df2`.


~~~
anti_join(df1, df2)
~~~
{: .language-r}



~~~
# A tibble: 1 x 2
  sample measure1
   <dbl>    <dbl>
1      2      5.3
~~~
{: .output}

For a more realistic example of joins, we will use the [`nycflights13`](https://github.com/hadley/nycflights13)
data set. This contains information about all flights out of New York City airports in 2013, along
with additional metadata. First, you will need to install the package and load the data: 

~~~~
install.packages("nycflights13")
library(nycflights13)
~~~~
{: .language-r}

This package includes five data frames:

* `flights`: Information about 336,776 flights departing from NYC airports in 2013
* `planes`: Construction information about individual planes
* `airports`: Name, location, and time zone information for airports
* `airlines`: Name and two letter code for airline companies
* `weather`: Weather data for each airport at hourly intervals

> ## Challenge 1
> Explore the data from `nycflights13`. Which columns from the `flights` data frame are shared with
> the other four?
> > ## Solution to Challenge 1
> >
> > * `flights` and `planes` share the `tailnum` and `year` columns, although in `flights`, `year`
> > refers to the year the flight took place (2013) and in `planes` it refers to the year the plane
> > was built
> > * `flights` and `airlines` share the `carrier` code column
> > * `flights` and `weather` share the `origin` and the time columns (`year`,`month`,`day`,`hour`,`time_hour`)
> > * `flights` and `airports` do not share a column name, but the `origin` and `dest` columns from 
> > `flights` have the three letter airport code in the `faa` column in `airports` 
> {: .solution}
{: .challenge}

One potential issue noted in the challenge above is that the column names you are trying to merge on
may not have the same name. In this case, you will need to provide a named vector to the `by` argument
indicating which columns from the left and right data frames are to be merged. For example, to find 
the names of all the destination airports from the `flights` data frame 


~~~
# Named 'dest' in the first data frame and 'faa' in the second
flights %>% 
  left_join(airports, by = c("dest" = "faa")) %>% 
  select(flight, origin, dest, name)
~~~
{: .language-r}



~~~
# A tibble: 336,776 x 4
   flight origin dest  name                           
    <int> <chr>  <chr> <chr>                          
 1   1545 EWR    IAH   George Bush Intercontinental   
 2   1714 LGA    IAH   George Bush Intercontinental   
 3   1141 JFK    MIA   Miami Intl                     
 4    725 JFK    BQN   <NA>                           
 5    461 LGA    ATL   Hartsfield Jackson Atlanta Intl
 6   1696 EWR    ORD   Chicago Ohare Intl             
 7    507 EWR    FLL   Fort Lauderdale Hollywood Intl 
 8   5708 LGA    IAD   Washington Dulles Intl         
 9     79 JFK    MCO   Orlando Intl                   
10    301 LGA    ORD   Chicago Ohare Intl             
# … with 336,766 more rows
~~~
{: .output}

> ## Challenge 2
> You will see above that one of the destination airports is not present in the `airports` data. Find
> all missing airports using an `anti_join()`. Find the most common unknown destination with `count()`
> and search for that airport code online to try and explain why it is missing.
> > ## Solution to Challenge 2
> > 
> > ~~~
> > flights %>% 
> >   anti_join(airports, by = c("dest" = "faa")) %>% 
> >   count(dest, sort = TRUE)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > # A tibble: 4 x 2
> >   dest      n
> >   <chr> <int>
> > 1 SJU    5819
> > 2 BQN     896
> > 3 STT     522
> > 4 PSE     365
> > ~~~
> > {: .output}
> > SJU is the code for the Luis Muñoz Marín International Airport in San Juan, Puerto Rico. The 
> > `airports` data set was likely constructed from a list of airports in US states, which would have
> > not included US territories such as Puerto Rico. 
> > 
> > This is a good reminder to always check your data to make sure that it is complete. Or at least
> > to make yourself aware of it's limitations.
> {: .solution}
{: .challenge}

By combining everything we have covered so far, it is possible to start asking more complex questions
of our data.

> ## Challenge 3
> Which is the most common route in the `flights` data and what is the destination airport name?
> > ## Solution to Challenge 3
> > 
> > ~~~
> > flights %>% 
> >   count(origin, dest, sort = T) %>% 
> >   left_join(airports, by = c("dest" = "faa"))
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > # A tibble: 224 x 10
> >    origin dest      n name            lat    lon   alt    tz dst   tzone   
> >    <chr>  <chr> <int> <chr>         <dbl>  <dbl> <int> <dbl> <chr> <chr>   
> >  1 JFK    LAX   11262 Los Angeles …  33.9 -118.    126    -8 A     America…
> >  2 LGA    ATL   10263 Hartsfield J…  33.6  -84.4  1026    -5 A     America…
> >  3 LGA    ORD    8857 Chicago Ohar…  42.0  -87.9   668    -6 A     America…
> >  4 JFK    SFO    8204 San Francisc…  37.6 -122.     13    -8 A     America…
> >  5 LGA    CLT    6168 Charlotte Do…  35.2  -80.9   748    -5 A     America…
> >  6 EWR    ORD    6100 Chicago Ohar…  42.0  -87.9   668    -6 A     America…
> >  7 JFK    BOS    5898 General Edwa…  42.4  -71.0    19    -5 A     America…
> >  8 LGA    MIA    5781 Miami Intl     25.8  -80.3     8    -5 A     America…
> >  9 JFK    MCO    5464 Orlando Intl   28.4  -81.3    96    -5 A     America…
> > 10 EWR    BOS    5327 General Edwa…  42.4  -71.0    19    -5 A     America…
> > # … with 214 more rows
> > ~~~
> > {: .output}
> {: .solution}
{: .challenge}

> ## Challenge 4
> What is the theoretical maximum number of passengers that could have been transported on each route? 
> 
> How do the top five routes differ between this ordering and the previous one?
>
> *Hint:* Some of the recorded plane tail numbers might not be present in the `planes` data frame.
> Which join function will allow us to only look at flights for which we have information about the
> plane's capacity?
> > ## Solution to Challenge 4
> > Can use the `seats` value from the `planes` data frame as the maximum capacity of each plane. 
> > Because the `year` column in `planes` records the year it was built, we need to make sure that
> > we don't try to merge this with the `year` column of the `flights` data frame which records the
> > year the flight took place.
> > 
> > ~~~
> > flights %>% 
> >   inner_join(planes, by = c("tailnum")) %>%
> >   group_by(origin, dest) %>% 
> >   summarise(max_cap = sum(seats))
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > # A tibble: 222 x 3
> > # Groups:   origin [?]
> >    origin dest  max_cap
> >    <chr>  <chr>   <int>
> >  1 EWR    ALB     24145
> >  2 EWR    ANC      1068
> >  3 EWR    ATL    574312
> >  4 EWR    AUS    155181
> >  5 EWR    AVL     14575
> >  6 EWR    BDL     25178
> >  7 EWR    BNA    177368
> >  8 EWR    BOS    612894
> >  9 EWR    BQN     45280
> > 10 EWR    BTV     51205
> > # … with 212 more rows
> > ~~~
> > {: .output}
> > The ordering of the top five routes differ slightly, with the JFK -> SFO route being fourth for
> > number of flights, but second for potential capacity. The other routes keep the same relative
> > ordering.
> {: .solution}
{: .challenge}
